/**
 * üë®‚Äçüíº Admin Notification Manager
 * Qu·∫£n l√Ω th√¥ng b√°o cho admin v√† h·ªá th·ªëng
 */

import { notificationDataManager } from './notification-data-manager.js';
import { errorHandler } from './error-handler.js';

export class AdminNotificationManager {
  constructor(options = {}) {
    this.options = {
      adminKey: 'admin-notifications-key',
      enableScheduling: true,
      enableBulkOperations: true,
      enableTemplates: true,
      maxScheduledNotifications: 100,
      ...options
    };
    
    this.scheduledNotifications = new Map();
    this.templates = new Map();
    this.isInitialized = false;
    
    this.init();
  }

  /**
   * Kh·ªüi t·∫°o admin manager
   */
  async init() {
    try {
      await this.loadScheduledNotifications();
      await this.loadTemplates();
      
      if (this.options.enableScheduling) {
        this.startScheduler();
      }
      
      this.isInitialized = true;
      console.log('üë®‚Äçüíº Admin Notification Manager initialized');
      
    } catch (error) {
      errorHandler.handle(error, { type: 'admin-notification-init' }, 'L·ªói kh·ªüi t·∫°o admin notification manager');
    }
  }

  /**
   * T·∫°o th√¥ng b√°o h·ªá th·ªëng
   */
  async createSystemNotification(data) {
    try {
      const notification = {
        ...data,
        type: 'system',
        category: 'system',
        priority: data.priority || 'normal',
        timestamp: Date.now(),
        metadata: {
          ...data.metadata,
          createdBy: 'system',
          source: 'admin'
        }
      };

      const id = await notificationDataManager.createNotification(notification);
      console.log(`üë®‚Äçüíº Created system notification: ${data.title}`);
      return id;
      
    } catch (error) {
      errorHandler.handle(error, { type: 'admin-create-system' }, 'L·ªói t·∫°o th√¥ng b√°o h·ªá th·ªëng');
      throw error;
    }
  }

  /**
   * T·∫°o th√¥ng b√°o c·∫≠p nh·∫≠t
   */
  async createUpdateNotification(version, changes, options = {}) {
    try {
      const notification = {
        title: `C·∫≠p nh·∫≠t phi√™n b·∫£n ${version}`,
        message: `H·ªá th·ªëng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t l√™n phi√™n b·∫£n ${version}. ${changes}`,
        type: 'update',
        category: 'system',
        priority: 'high',
        persistent: true,
        actionUrl: options.changelogUrl || '#/',
        actionText: 'Xem chi ti·∫øt',
        metadata: {
          version,
          changes,
          updateType: options.updateType || 'minor',
          createdBy: 'system'
        },
        ...options
      };

      const id = await this.createSystemNotification(notification);
      console.log(`üîÑ Created update notification for version ${version}`);
      return id;
      
    } catch (error) {
      errorHandler.handle(error, { type: 'admin-create-update' }, 'L·ªói t·∫°o th√¥ng b√°o c·∫≠p nh·∫≠t');
      throw error;
    }
  }

  /**
   * T·∫°o th√¥ng b√°o phim m·ªõi
   */
  async createMovieNotification(movieData, options = {}) {
    try {
      const notification = {
        title: options.title || `Phim m·ªõi: ${movieData.name || movieData.title}`,
        message: options.message || `ƒê√£ th√™m phim "${movieData.name || movieData.title}" v√†o th∆∞ vi·ªán. H√£y xem ngay!`,
        type: 'movie',
        category: 'movie',
        priority: 'normal',
        actionUrl: options.actionUrl || `#/phim/${movieData.slug}`,
        actionText: 'Xem phim',
        metadata: {
          movieId: movieData.id || movieData._id,
          movieSlug: movieData.slug,
          movieType: movieData.type,
          createdBy: 'system'
        },
        ...options
      };

      const id = await notificationDataManager.createNotification(notification);
      console.log(`üé¨ Created movie notification: ${movieData.name || movieData.title}`);
      return id;
      
    } catch (error) {
      errorHandler.handle(error, { type: 'admin-create-movie' }, 'L·ªói t·∫°o th√¥ng b√°o phim');
      throw error;
    }
  }

  /**
   * T·∫°o th√¥ng b√°o b·∫£o tr√¨
   */
  async createMaintenanceNotification(startTime, endTime, reason, options = {}) {
    try {
      const startDate = new Date(startTime).toLocaleString('vi-VN');
      const endDate = new Date(endTime).toLocaleString('vi-VN');
      
      const notification = {
        title: 'Th√¥ng b√°o b·∫£o tr√¨ h·ªá th·ªëng',
        message: `H·ªá th·ªëng s·∫Ω b·∫£o tr√¨ t·ª´ ${startDate} ƒë·∫øn ${endDate}. L√Ω do: ${reason}`,
        type: 'warning',
        category: 'system',
        priority: 'high',
        persistent: true,
        metadata: {
          maintenanceStart: startTime,
          maintenanceEnd: endTime,
          reason,
          createdBy: 'admin'
        },
        ...options
      };

      const id = await this.createSystemNotification(notification);
      console.log(`‚ö†Ô∏è Created maintenance notification`);
      return id;
      
    } catch (error) {
      errorHandler.handle(error, { type: 'admin-create-maintenance' }, 'L·ªói t·∫°o th√¥ng b√°o b·∫£o tr√¨');
      throw error;
    }
  }

  /**
   * T·∫°o th√¥ng b√°o khuy·∫øn m√£i/s·ª± ki·ªán
   */
  async createPromotionNotification(title, description, options = {}) {
    try {
      const notification = {
        title,
        message: description,
        type: 'info',
        category: 'promotion',
        priority: 'normal',
        actionUrl: options.actionUrl,
        actionText: options.actionText || 'Tham gia ngay',
        expiresAt: options.expiresAt,
        metadata: {
          promotionType: options.promotionType || 'general',
          createdBy: 'admin'
        },
        ...options
      };

      const id = await notificationDataManager.createNotification(notification);
      console.log(`üéâ Created promotion notification: ${title}`);
      return id;
      
    } catch (error) {
      errorHandler.handle(error, { type: 'admin-create-promotion' }, 'L·ªói t·∫°o th√¥ng b√°o khuy·∫øn m√£i');
      throw error;
    }
  }

  /**
   * L√™n l·ªãch th√¥ng b√°o
   */
  async scheduleNotification(notificationData, scheduledTime) {
    try {
      if (!this.options.enableScheduling) {
        throw new Error('Scheduling is disabled');
      }

      const scheduleId = `schedule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      const scheduledNotification = {
        id: scheduleId,
        notificationData,
        scheduledTime,
        status: 'pending',
        createdAt: Date.now(),
        createdBy: 'admin'
      };

      this.scheduledNotifications.set(scheduleId, scheduledNotification);
      await this.saveScheduledNotifications();
      
      console.log(`üìÖ Scheduled notification for ${new Date(scheduledTime).toLocaleString('vi-VN')}`);
      return scheduleId;
      
    } catch (error) {
      errorHandler.handle(error, { type: 'admin-schedule' }, 'L·ªói l√™n l·ªãch th√¥ng b√°o');
      throw error;
    }
  }

  /**
   * H·ªßy th√¥ng b√°o ƒë√£ l√™n l·ªãch
   */
  async cancelScheduledNotification(scheduleId) {
    try {
      const scheduled = this.scheduledNotifications.get(scheduleId);
      if (!scheduled) {
        throw new Error('Scheduled notification not found');
      }

      scheduled.status = 'cancelled';
      await this.saveScheduledNotifications();
      
      console.log(`‚ùå Cancelled scheduled notification: ${scheduleId}`);
      return true;
      
    } catch (error) {
      errorHandler.handle(error, { type: 'admin-cancel-schedule' }, 'L·ªói h·ªßy th√¥ng b√°o ƒë√£ l√™n l·ªãch');
      throw error;
    }
  }

  /**
   * T·∫°o th√¥ng b√°o h√†ng lo·∫°t
   */
  async createBulkNotifications(notifications) {
    try {
      if (!this.options.enableBulkOperations) {
        throw new Error('Bulk operations are disabled');
      }

      const results = [];
      const errors = [];

      for (const notificationData of notifications) {
        try {
          const id = await notificationDataManager.createNotification({
            ...notificationData,
            metadata: {
              ...notificationData.metadata,
              createdBy: 'admin',
              bulkOperation: true
            }
          });
          results.push({ success: true, id, data: notificationData });
        } catch (error) {
          errors.push({ success: false, error: error.message, data: notificationData });
        }
      }

      console.log(`üì¶ Bulk created ${results.length} notifications, ${errors.length} errors`);
      return { results, errors };
      
    } catch (error) {
      errorHandler.handle(error, { type: 'admin-bulk-create' }, 'L·ªói t·∫°o th√¥ng b√°o h√†ng lo·∫°t');
      throw error;
    }
  }

  /**
   * X√≥a th√¥ng b√°o h√†ng lo·∫°t theo ƒëi·ªÅu ki·ªán
   */
  async deleteBulkNotifications(criteria) {
    try {
      if (!this.options.enableBulkOperations) {
        throw new Error('Bulk operations are disabled');
      }

      const notifications = notificationDataManager.getNotifications(criteria);
      let deletedCount = 0;

      for (const notification of notifications) {
        try {
          await notificationDataManager.deleteNotification(notification.id);
          deletedCount++;
        } catch (error) {
          console.warn(`Failed to delete notification ${notification.id}:`, error);
        }
      }

      console.log(`üóëÔ∏è Bulk deleted ${deletedCount} notifications`);
      return deletedCount;
      
    } catch (error) {
      errorHandler.handle(error, { type: 'admin-bulk-delete' }, 'L·ªói x√≥a th√¥ng b√°o h√†ng lo·∫°t');
      throw error;
    }
  }

  /**
   * T·∫°o template th√¥ng b√°o
   */
  async createTemplate(name, template) {
    try {
      if (!this.options.enableTemplates) {
        throw new Error('Templates are disabled');
      }

      const templateData = {
        name,
        template: {
          title: template.title || '',
          message: template.message || '',
          type: template.type || 'info',
          category: template.category || 'general',
          priority: template.priority || 'normal',
          ...template
        },
        createdAt: Date.now(),
        createdBy: 'admin'
      };

      this.templates.set(name, templateData);
      await this.saveTemplates();
      
      console.log(`üìù Created notification template: ${name}`);
      return name;
      
    } catch (error) {
      errorHandler.handle(error, { type: 'admin-create-template' }, 'L·ªói t·∫°o template th√¥ng b√°o');
      throw error;
    }
  }

  /**
   * S·ª≠ d·ª•ng template ƒë·ªÉ t·∫°o th√¥ng b√°o
   */
  async createFromTemplate(templateName, variables = {}) {
    try {
      const template = this.templates.get(templateName);
      if (!template) {
        throw new Error(`Template not found: ${templateName}`);
      }

      // Replace variables in template
      const notificationData = { ...template.template };
      
      Object.entries(variables).forEach(([key, value]) => {
        const placeholder = `{{${key}}}`;
        if (notificationData.title) {
          notificationData.title = notificationData.title.replace(new RegExp(placeholder, 'g'), value);
        }
        if (notificationData.message) {
          notificationData.message = notificationData.message.replace(new RegExp(placeholder, 'g'), value);
        }
      });

      notificationData.metadata = {
        ...notificationData.metadata,
        templateUsed: templateName,
        variables,
        createdBy: 'admin'
      };

      const id = await notificationDataManager.createNotification(notificationData);
      console.log(`üìù Created notification from template: ${templateName}`);
      return id;
      
    } catch (error) {
      errorHandler.handle(error, { type: 'admin-template-create' }, 'L·ªói t·∫°o th√¥ng b√°o t·ª´ template');
      throw error;
    }
  }

  /**
   * L·∫•y th·ªëng k√™ th√¥ng b√°o
   */
  getNotificationStatistics(timeRange = 'all') {
    try {
      const stats = notificationDataManager.getStatistics();
      const now = Date.now();
      let fromTime = 0;

      switch (timeRange) {
        case 'today':
          fromTime = now - 24 * 60 * 60 * 1000;
          break;
        case 'week':
          fromTime = now - 7 * 24 * 60 * 60 * 1000;
          break;
        case 'month':
          fromTime = now - 30 * 24 * 60 * 60 * 1000;
          break;
      }

      if (fromTime > 0) {
        const notifications = notificationDataManager.getNotifications({ fromDate: fromTime });
        return {
          ...stats,
          timeRange,
          filtered: {
            total: notifications.length,
            unread: notifications.filter(n => !n.isRead).length,
            byType: this.groupBy(notifications, 'type'),
            byCategory: this.groupBy(notifications, 'category'),
            byPriority: this.groupBy(notifications, 'priority')
          }
        };
      }

      return { ...stats, timeRange };
      
    } catch (error) {
      errorHandler.handle(error, { type: 'admin-stats' }, 'L·ªói l·∫•y th·ªëng k√™ th√¥ng b√°o');
      return null;
    }
  }

  /**
   * Group by field
   */
  groupBy(items, field) {
    return items.reduce((groups, item) => {
      const key = item[field] || 'unknown';
      groups[key] = (groups[key] || 0) + 1;
      return groups;
    }, {});
  }

  /**
   * L·∫•y danh s√°ch th√¥ng b√°o ƒë√£ l√™n l·ªãch
   */
  getScheduledNotifications() {
    return Array.from(this.scheduledNotifications.values())
      .sort((a, b) => a.scheduledTime - b.scheduledTime);
  }

  /**
   * L·∫•y danh s√°ch templates
   */
  getTemplates() {
    return Array.from(this.templates.values());
  }

  /**
   * Load scheduled notifications t·ª´ storage
   */
  async loadScheduledNotifications() {
    try {
      const stored = localStorage.getItem('admin-scheduled-notifications');
      if (stored) {
        const data = JSON.parse(stored);
        this.scheduledNotifications = new Map(data.notifications || []);
      }
    } catch (error) {
      console.warn('Failed to load scheduled notifications:', error);
      this.scheduledNotifications = new Map();
    }
  }

  /**
   * Save scheduled notifications v√†o storage
   */
  async saveScheduledNotifications() {
    try {
      const data = {
        notifications: Array.from(this.scheduledNotifications.entries()),
        lastUpdated: Date.now()
      };
      localStorage.setItem('admin-scheduled-notifications', JSON.stringify(data));
    } catch (error) {
      console.warn('Failed to save scheduled notifications:', error);
    }
  }

  /**
   * Load templates t·ª´ storage
   */
  async loadTemplates() {
    try {
      const stored = localStorage.getItem('admin-notification-templates');
      if (stored) {
        const data = JSON.parse(stored);
        this.templates = new Map(data.templates || []);
      } else {
        // Create default templates
        await this.createDefaultTemplates();
      }
    } catch (error) {
      console.warn('Failed to load templates:', error);
      this.templates = new Map();
    }
  }

  /**
   * Save templates v√†o storage
   */
  async saveTemplates() {
    try {
      const data = {
        templates: Array.from(this.templates.entries()),
        lastUpdated: Date.now()
      };
      localStorage.setItem('admin-notification-templates', JSON.stringify(data));
    } catch (error) {
      console.warn('Failed to save templates:', error);
    }
  }

  /**
   * T·∫°o default templates
   */
  async createDefaultTemplates() {
    const defaultTemplates = [
      {
        name: 'system-update',
        template: {
          title: 'C·∫≠p nh·∫≠t h·ªá th·ªëng {{version}}',
          message: 'H·ªá th·ªëng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t l√™n phi√™n b·∫£n {{version}}. {{changes}}',
          type: 'update',
          category: 'system',
          priority: 'high'
        }
      },
      {
        name: 'new-movie',
        template: {
          title: 'Phim m·ªõi: {{movieName}}',
          message: 'ƒê√£ th√™m phim "{{movieName}}" v√†o th∆∞ vi·ªán. H√£y xem ngay!',
          type: 'movie',
          category: 'movie',
          priority: 'normal'
        }
      },
      {
        name: 'maintenance',
        template: {
          title: 'Th√¥ng b√°o b·∫£o tr√¨ h·ªá th·ªëng',
          message: 'H·ªá th·ªëng s·∫Ω b·∫£o tr√¨ t·ª´ {{startTime}} ƒë·∫øn {{endTime}}. L√Ω do: {{reason}}',
          type: 'warning',
          category: 'system',
          priority: 'high'
        }
      }
    ];

    for (const template of defaultTemplates) {
      this.templates.set(template.name, {
        ...template,
        createdAt: Date.now(),
        createdBy: 'system'
      });
    }

    await this.saveTemplates();
  }

  /**
   * Start scheduler ƒë·ªÉ x·ª≠ l√Ω th√¥ng b√°o ƒë√£ l√™n l·ªãch
   */
  startScheduler() {
    setInterval(() => {
      this.processScheduledNotifications();
    }, 60000); // Check every minute
  }

  /**
   * Process scheduled notifications
   */
  async processScheduledNotifications() {
    const now = Date.now();
    const toProcess = [];

    this.scheduledNotifications.forEach((scheduled, id) => {
      if (scheduled.status === 'pending' && scheduled.scheduledTime <= now) {
        toProcess.push({ id, scheduled });
      }
    });

    for (const { id, scheduled } of toProcess) {
      try {
        await notificationDataManager.createNotification({
          ...scheduled.notificationData,
          metadata: {
            ...scheduled.notificationData.metadata,
            scheduledId: id,
            originalScheduledTime: scheduled.scheduledTime
          }
        });

        scheduled.status = 'sent';
        scheduled.sentAt = now;
        
        console.log(`üìÖ Sent scheduled notification: ${id}`);
        
      } catch (error) {
        scheduled.status = 'failed';
        scheduled.error = error.message;
        console.error(`Failed to send scheduled notification ${id}:`, error);
      }
    }

    if (toProcess.length > 0) {
      await this.saveScheduledNotifications();
    }
  }

  /**
   * Destroy admin manager
   */
  destroy() {
    console.log('üë®‚Äçüíº Admin Notification Manager destroyed');
  }
}

// Export singleton instance
export const adminNotificationManager = new AdminNotificationManager();
